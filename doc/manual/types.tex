\chapter{Datatypes}
\begin{synopsis}
\end{synopsis}
\minitoc
\vspace{\fill}
\newpage

\defapi{adj_adjointer}
\defapis{adj_create_adjointer}
\begin{boxwithtitle}{\texttt{adj_create_adjointer}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_create_adjointer(adj_adjointer* adjointer);
\end{ccode}
\begin{fortrancode}
  function adj_create_adjointer(adjointer) result(ierr) 
    type(adj_adjointer), intent(inout) :: adjointer
    integer(kind=c_int) :: ierr
  end function adj_create_adjointer
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function creates an \refapi{adj_adjointer} object. 
It stores all details needed for the assembly of the adjoint equations, in particular the annotation of the forward model and the associated callbacks routines.

The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_destroy_adjointer}
\begin{boxwithtitle}{\texttt{adj_destroy_adjointer}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_destroy_adjointer(adj_adjointer* adjointer);
\end{ccode}
\begin{fortrancode}
  function adj_destroy_adjointer(adjointer) result(ierr) 
    type(adj_adjointer), intent(inout) :: adjointer
    integer(kind=c_int) :: ierr
  end function adj_destroy_adjointer
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function destroys the supplied \refapi{adj_adjointer} object.

The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_deactivate_adjointer}
\begin{boxwithtitle}{\texttt{adj_deactivate_adjointer}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_deactivate_adjointer(adj_adjointer* adjointer);
\end{ccode}
\begin{fortrancode}
  function adj_deactivate_adjointer(adjointer) result(ierr) 
    type(adj_adjointer), intent(inout) :: adjointer
    integer(kind=c_int) :: ierr
  end function adj_deactivate_adjointer
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Deactivates the supplied \refapi{adj_adjointer}.
In particular, the model annotation, the callback registration and the recording functions are replaced by dummy functions within \texttt{libadjoint} that always return \refapi{ADJ_OK}.

This functionality is primarily used to deactivate the adjoint features for cases where only the forward model result is of interest.

The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapi{adj_variable}

\defapis{adj_create_variable}
\begin{boxwithtitle}{\texttt{adj_create_variable}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_create_variable(char* name, int timestep, int iteration, int auxiliary, 
                          adj_variable* var);
\end{ccode}
\begin{fortrancode}
  function adj_create_variable(name, timestep, iteration, auxiliary, variable) 
           result(ierr)
    character(len=*), intent(in) :: name
    integer, intent(in) :: timestep, iteration
    logical, intent(in) :: auxiliary
    type(adj_variable), intent(out) :: variable
    integer :: ierr
  end function adj_create_variable
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function creates an \texttt{adj_variable} with the given \texttt{name} (used to identify the variable), \texttt{timestep} and \texttt{iteration}.
The \texttt{auxiliary} option defines the type of the variable and must be either \texttt{ADJ_NORMAL_VARIABLE} or \texttt{ADJ_AUXILIARY_VARIABLE}.
The function returns an error code that can be passed to \refapi{adj_chkierr}.

Auxiliary variables are variables for which no equation is solved, but are necessary for the evaluation of an operator.
A typical example for an auxiliary variable is the computational mesh, which is needed for the assembly of the discretised operators but for which no equation is solved during the simulation.
An alternative way of passing objects to the callback functions is to use the \texttt{context} pointer in \refapi{adj_create_block} and \refapi{adj_create_nonlinear_block}.

Helper functions are available to change the properties of a variable after initialisation, see below. 



\defapis{adj_variable_get_name}
\begin{boxwithtitle}{\texttt{adj_variable_get_name}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_variable_get_name(adj_variable var, char** name);
\end{ccode}
\begin{fortrancode}
  function adj_variable_get_name(variable, name) result(ierr)
    type(adj_variable), intent(in) :: variable
    character(len=*), intent(out) :: name
    integer :: ierr
  end function adj_variable_get_name
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function is used to query the \texttt{name} of an \texttt{adj_variable}.
The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_variable_get_timestep}
\begin{boxwithtitle}{\texttt{adj_variable_get_timestep}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_variable_get_timestep(adj_variable var, int* timestep);
\end{ccode}
\begin{fortrancode}
  function adj_variable_get_timestep(var, timestep) result(ierr)
    type(adj_variable), intent(in), value :: var
    integer(kind=c_int), intent(out) :: timestep
    integer(kind=c_int) :: ierr
  end function adj_variable_get_timestep
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function is used to query the \texttt{timestep} of an \texttt{adj_variable}.
The function returns an error code that can be passed to \refapi{adj_chkierr}.


\defapis{adj_variable_get_iteration}
\begin{boxwithtitle}{\texttt{adj_variable_get_iteration}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_variable_get_iteration(adj_variable var, int* iteration);
\end{ccode}
\begin{fortrancode}
  function adj_variable_get_iteration(var, iteration) result(ierr) 
    type(adj_variable), intent(in), value :: var
    integer(kind=c_int), intent(out) :: iteration
    integer(kind=c_int) :: ierr
  end function adj_variable_get_iteration
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function is used to query the \texttt{iteration} of an \texttt{adj_variable}.
The function returns an error code that can be passed to \refapi{adj_chkierr}.


\defapis{adj_variable_set_auxiliary}
\begin{boxwithtitle}{\texttt{adj_variable_set_auxiliary}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_variable_set_auxiliary(adj_variable* var, int auxiliary);
\end{ccode}
\begin{fortrancode}
  function adj_variable_set_auxiliary(var, auxiliary) result(ierr)
    type(adj_variable), intent(inout) :: var
    logical, intent(in) :: auxiliary
    integer(kind=c_int) :: ierr
  end function adj_variable_set_auxiliary
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function is used to define the type of an \texttt{adj_variable}.
\texttt{auxiliary} must be either \texttt{ADJ_NORMAL_VARIABLE} or \texttt{ADJ_AUXILIARY_VARIABLE}.
The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapi{adj_block}

\defapis{adj_create_block}
\begin{boxwithtitle}{\texttt{adj_create_block}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_create_block(char* name, adj_nonlinear_block* nblock, void* context, 
                       adj_block* block);
\end{ccode}
\begin{fortrancode}
  function adj_create_block(name, nblock, context, block) result(ierr)
    character(len=*), intent(in) :: name
    type(adj_nonlinear_block), intent(in), optional, target :: nblock
    type(c_ptr), intent(in), optional :: context
    type(adj_block), intent(inout) :: block
    integer :: ierr
  end function adj_create_block
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function creates an \texttt{adj_block} with the given \texttt{name}.
If the block is nonlinear, the corresponding \refapi{adj_nonlinear_block} is passed as \texttt{nblock}. 
Otherwise, a \texttt{NULL} pointer is to be passed in C and the argument can be ignored in Fortran.
The void pointer \texttt{context} allows the developer to pass arbitrary data to the block's callbacks (\refapi{ADJ_BLOCK_ACTION_CB}, \refapi{ADJ_BLOCK_ASSEMBLY_CB}) of this operator. 
The resulting block is stored in \texttt{block}. 
The return value is an error code that can be passed to \refapi{adj_chkierr}.

In addition, \texttt{adj_block} has properties that are not directly accessible during the initialisation:

\begin{description}
  \item[hermitian] A flag indicating if the hermitian of the operator is to be used. Default: \texttt{ADJ_FALSE}
  \item[coefficient] A scaling factor. Default: 1.0
\end{description}

Helper functions are available to change these values, see below. 


\defapis{adj_block_set_coefficient}
\begin{boxwithtitle}{\texttt{adj_block_set_coefficient}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_block_set_coefficient(adj_block* block, adj_scalar coefficient);
\end{ccode}
\begin{fortrancode}
  function adj_nonlinear_block_set_coefficient(nblock, coefficient) result(ierr)
    type(adj_nonlinear_block), intent(inout) :: nblock
    adj_scalar_f, intent(in), value :: coefficient
    integer(kind=c_int) :: ierr
  end function adj_nonlinear_block_set_coefficient
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function sets the scaling of a block to \texttt{coefficient}. 
The return value is an error code that can be passed to \refapi{adj_chkierr}.


\defapis{adj_block_set_hermitian}
\begin{boxwithtitle}{\texttt{adj_block_set_hermitian}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_block_set_hermitian(adj_block* block, int hermitian);
\end{ccode}
\begin{fortrancode}
  function adj_block_set_hermitian(block, hermitian) result(ierr)
    type(adj_block), intent(inout) :: block
    logical, intent(in) :: hermitian
    integer(kind=c_int) :: ierr
  end function adj_block_set_hermitian
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function sets the hermitian flag of \texttt{block}. \texttt{hermitian} must be \texttt{ADJ_TRUE} or \texttt{ADJ_FALSE}.
The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_destroy_block}
\begin{boxwithtitle}{\texttt{adj_destroy_block}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_destroy_block(adj_block* block);
\end{ccode}
\begin{fortrancode}
  function adj_destroy_block(block) result(ierr) 
    type(adj_block), intent(inout) :: block
    integer(kind=c_int) :: ierr
  end function adj_destroy_block
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Destroys the block \texttt{block}.
The return value is an error code that can be passed to \refapi{adj_chkierr}.


\defapi{adj_nonlinear_block}

\defapis{adj_create_nonlinear_block}
\begin{boxwithtitle}{\texttt{adj_create_nonlinear_block}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_create_nonlinear_block(char* name, int ndepends, adj_variable* depends, 
                                 void* context, adj_nonlinear_block* nblock);
\end{ccode}
\begin{fortrancode}
  function adj_create_nonlinear_block(name, depends, coefficient, context, nblock) 
           result(ierr)
    character(len=*), intent(in) :: name
    type(adj_variable), intent(in), dimension(:) :: depends
    adj_scalar_f, intent(in), optional :: coefficient
    type(c_ptr), intent(in), optional :: context
    type(adj_nonlinear_block), intent(out) :: nblock
    integer :: ierr
  end function adj_create_nonlinear_block
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}
This function creates an \texttt{adj_nonlinear_block} with the given \texttt{name}.
The dependency variables are passed with \texttt{depends} (and \texttt{ndepends} in C which specifies the length of the array).
At least one dependency must be given.
The void pointer \texttt{context} allows the developer to pass arbitrary data to the nonlinear block's callbacks (\refapi{ADJ_NBLOCK_DERIVATIVE_ACTION_CB}, \refapi{ADJ_NBLOCK_ACTION_CB}) of this operator.

The resulting nonlinear block is stored in \texttt{nblock}. 
The return value is an error code that can be passed to \refapi{adj_chkierr}.

In addition, \texttt{adj_nonlinear_block} has a scaling property that is not directly accessible during the initialisation. 
Its default value is set to 1.0, but can be changed using \refapi{adj_nonlinear_block_set_coefficient}, see below.


\defapis{adj_nonlinear_block_set_coefficient}
\begin{boxwithtitle}{\texttt{adj_nonlinear_block_set_coefficient}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_nonlinear_block_set_coefficient(adj_nonlinear_block* nblock, 
                                          adj_scalar coefficient);
\end{ccode}
\begin{fortrancode}
  function adj_nonlinear_block_set_coefficient(nblock, coefficient) result(ierr) 
    type(adj_nonlinear_block), intent(inout) :: nblock
    adj_scalar_f, intent(in), value :: coefficient
    integer(kind=c_int) :: ierr
  end function adj_nonlinear_block_set_coefficient
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}
This function sets the scaling of a nonlinear block to \texttt{coefficient}. 
The return value is an error code that can be passed to \refapi{adj_chkierr}.


\defapis{adj_destroy_nonlinear_block}
\begin{boxwithtitle}{\texttt{adj_destroy_nonlinear_block}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_destroy_nonlinear_block(adj_nonlinear_block* nblock);
\end{ccode}
\begin{fortrancode}
  function adj_destroy_nonlinear_block(nblock) result(ierr)
    type(adj_nonlinear_block), intent(inout) :: nblock
    integer(kind=c_int) :: ierr
  end function adj_destroy_nonlinear_block
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}
Destroys the nonlinear block \texttt{nblock}.
The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapi{adj_equation}

\defapis{adj_create_equation}
\begin{boxwithtitle}{\texttt{adj_create_equation}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_create_equation(adj_variable var, int nblocks, adj_block* blocks, 
                          adj_variable* targets, adj_equation* equation);
\end{ccode}
\begin{fortrancode}
  function adj_create_equation(variable, blocks, targets, equation) result(ierr)
    type(adj_variable), intent(in), value :: variable
    type(adj_block), dimension(:), intent(in) :: blocks
    type(adj_variable), dimension(:), intent(in) :: targets
    type(adj_equation), intent(inout) :: equation
    integer :: ierr
  end function adj_create_equation
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}
This function creates an \refapi{adj_equation} that solves for \texttt{var}.

\texttt{blocks} and \texttt{targets} are arrays of length \texttt{nblocks} that describe the equation:
The first block of the blocks array is to be multiplied with the first variable in the targets array, 
the second pairs with the second, and so on.
The right hand side of the equation is neglected since it irrelevant for the adjoint equation. 
Hence, the variable to be solvedi for, \texttt{var}, must exist in \texttt{targets}. If that is not the case an \refapi{ADJ_ERR_INVALID_INPUTS} is returned.
 

The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_equation_set_rhs_dependencies}
\begin{boxwithtitle}{\texttt{adj_equation_set_rhs_dependencies}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_equation_set_rhs_dependencies(adj_equation* equation, int nrhsdeps, 
                                        adj_variable* rhsdeps, void* context);
\end{ccode}
\begin{fortrancode}
  function adj_equation_set_rhs_dependencies(equation, rhsdeps, context) 
           result(ierr)
    type(adj_equation), intent(inout) :: equation
    type(adj_variable), dimension(:), intent(in), optional :: rhsdeps
    type(c_ptr), intent(in), value, optional :: context
    integer(kind=c_int) :: ierr
  end function adj_equation_set_rhs_dependencies
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Sets the dependency variables and the context for the right hand side evaluation of \texttt{equation}. 

This information will passed to the source term callback function, if a source term is defined (see \refapi{adj_register_forward_source_callback}).
Otherwise this function can be ignored.

The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_register_equation}
\begin{boxwithtitle}{\texttt{adj_register_equation}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_register_equation(adj_adjointer* adjointer, adj_equation equation);
\end{ccode}
\begin{fortrancode}
  function adj_register_equation(adjointer, equation) result(ierr)
    type(adj_adjointer), intent(inout) :: adjointer
    type(adj_equation), intent(in), value :: equation
    integer(kind=c_int) :: ierr
  end function adj_register_equation
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Adds the \texttt{equation} to the \texttt{adjointer}.

The return value is an error code that can be passed to \refapi{adj_chkierr}.


\defapis{adj_destroy_equation}
\begin{boxwithtitle}{\texttt{adj_destroy_equation}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_destroy_equation(adj_equation* equation);
\end{ccode}
\begin{fortrancode}
  function adj_destroy_equation(equation) result(ierr)
    type(adj_equation), intent(inout) :: equation
    integer(kind=c_int) :: ierr
  end function adj_destroy_equation
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Destroys the equation \texttt{equation}.

The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapi{adj_storage_data}

\defapis{adj_storage_memory_copy}
\begin{boxwithtitle}{\texttt{adj_storage_memory_copy}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_storage_memory_copy(adj_vector value, adj_storage_data* data);
\end{ccode}
\begin{fortrancode}
  function adj_storage_memory_copy(val, mem) result(ierr)
    type(adj_vector), intent(in), value :: val
    type(adj_storage_data), intent(inout) :: mem
    integer(kind=c_int) :: ierr
  end function adj_storage_memory_copy
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}
Creates a \refapi{adj_storage} object that contains the supplied \refapi{adj_vector} \texttt{val}.

When the resulting \refapi{adj_storage} is used to record a variable (see \refapi{adj_record_variable}), 
a copy of \texttt{val} is created using the data callbacks \refapi{vec_duplicate} and \refapi{vec_axpy}.

The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_storage_memory_incref}
\begin{boxwithtitle}{\texttt{adj_storage_memory_incref}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_storage_memory_incref(adj_vector value, adj_storage_data* data);
\end{ccode}
\begin{fortrancode}
  function adj_storage_memory_incref(val, mem) result(ierr)
    type(adj_vector), intent(in), value :: val
    type(adj_storage_data), intent(inout) :: mem
    integer(kind=c_int) :: ierr
  end function adj_storage_memory_incref
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}
Creates a \refapi{adj_storage} object that contains the supplied \refapi{adj_vector} \texttt{val}.

When the resulting \refapi{adj_storage} is used to record a variable (see \refapi{adj_record_variable}), 
then only the pointer to \texttt{var} is recorded and the model developer has to ensure that the underlying data remains valid 
(for example with reference counting).

The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_record_variable}
\begin{boxwithtitle}{\texttt{adj_record_variable}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_record_variable(adj_adjointer* adjointer, adj_variable var, 
                          adj_storage_data storage);
\end{ccode}
\begin{fortrancode}
  function adj_record_variable(adjointer, variable, storage) result(ierr) 
    type(adj_adjointer), intent(inout) :: adjointer
    type(adj_variable), intent(in), value :: variable
    type(adj_storage_data), intent(in), value :: storage
    integer(kind=c_int) :: ierr
  end function adj_record_variable
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}
Records the variable \texttt{var} in \texttt{adjointer} with the data and storage strategy defined in \texttt{storage}.

The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapi{adj_dict}

\refapi{adj_dict} is an implementation of a dictionary class for strings.

Why is it public in libadjoint and how could it be used for the model developer?

\defapis{adj_dict_init}
\begin{boxwithtitle}{\texttt{adj_dict_init}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_dict_init(adj_dictionary* dict);
\end{ccode}
\begin{fortrancode}
  function adj_dict_init(dict) result(ierr)
    type(adj_dictionary), intent(inout) :: dict
    integer(kind=c_int) :: ierr
  end function adj_dict_init
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}
Creates a new dictionary \texttt{dict}.

The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_dict_set}
\begin{boxwithtitle}{\texttt{adj_dict_set}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_dict_set(adj_dictionary* dict, char* key, char* value);
\end{ccode}
\begin{fortrancode}
  function adj_dict_set(dict, key, value) result(ierr)
    type(adj_dictionary), intent(inout) :: dict
    character(len=*), intent(in) :: key, value
    integer :: ierr
  end function adj_dict_set
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Creates or updates an entry in the dictionary \texttt{dict} with key \texttt{key} and value \texttt{value}.

The return value is an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_dict_find}
\begin{boxwithtitle}{\texttt{adj_dict_find}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_dict_find(adj_dictionary* dict, char* key, char** value);
\end{ccode}
\begin{fortrancode}
  function adj_dict_find(dict, key, value) result(ierr)
    type(adj_dictionary), intent(inout) :: dict
    character(len=*), intent(in) :: key
    character(len=*), intent(out) :: value
    integer :: ierr
  end function adj_dict_find
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Finds an entry in the dictionary \texttt{dict} with key \texttt{key}.

If no corresponding key exist in the dictionary, the function returns \refapi{ADJ_ERR_DICT_FAILED}.
Otherwise, the value can be accessed with \texttt{value}.

The return value is an error code that can be passed to \refapi{adj_chkierr}.


\defapis{adj_dict_print}
\begin{boxwithtitle}{\texttt{adj_dict_print}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  void adj_dict_print(adj_dictionary* dict);
\end{ccode}
\begin{fortrancode}
  subroutine adj_dict_print(dict)
    type(adj_dictionary), intent(inout) :: dict
  end subroutine adj_dict_print
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Prints the key $\to$ value list in \texttt{dict} to \texttt{STDOUT}. 

\defapis{adj_dict_destroy}
\begin{boxwithtitle}{\texttt{adj_dict_destroy}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_dict_destroy(adj_dictionary* dict);
\end{ccode}
\begin{fortrancode}
  function adj_dict_destroy(dict) result(ierr)
    type(adj_dictionary), intent(inout) :: dict
    integer(kind=c_int) :: ierr
  end function adj_dict_destroy
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

Destroys the dictionary \texttt{dict}.

The return value is an error code that can be passed to \refapi{adj_chkierr}.
