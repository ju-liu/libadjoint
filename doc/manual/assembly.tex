\chapter{Assembling equations}
\begin{synopsis}
\end{synopsis}
\minitoc
\vspace{\fill}
\newpage


\section{Assembling the adjoint equations} \label{sec:adjoint_assembly}
\defapis{adj_get_adjoint_equation} 

\begin{boxwithtitle}{\texttt{adj_get_adjoint_equation}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_get_adjoint_equation(adj_adjointer* adjointer, int equation, 
                               char* functional, adj_matrix* lhs, 
                               adj_vector* rhs, adj_variable* adj_var)
\end{ccode}
\begin{fortrancode}   
  function adj_get_adjoint_equation(adjointer, equation, functional, lhs, rhs, 
                                    adj_var) result(ierr)
    type(adj_adjointer), intent(inout) :: adjointer
    integer(kind=c_int), intent(in), value :: equation
    character(len=*), intent(in) :: functional
    type(adj_matrix), intent(out) :: lhs
    type(adj_vector), intent(out) :: rhs
    type(adj_variable), intent(out) :: adj_var
    integer(kind=c_int) :: ierr
  end function adj_get_adjoint_equation
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This is the core function of libadjoint. 
It assembles the adjoint equation with index \texttt{equation} for the functional given by \texttt{functional}.
The result is a linear system with operator \texttt{lhs} and right hand side \texttt{rhs}. 
In addition, the \refapi{adj_variable} that this adjoint equation targets is provided as \texttt{adj_var}.

The function returns an error code that can be passed to \refapi{adj_chkierr}.

\section{A typical adjoint main loop}

Once the developer has annotated the model and provided the all necessary callbacks to libadjoint, 
everything is in place to assemble and solve the adjoint equations. 

Libadjoint is designed such that the program loop for solving the adjoint equations is simple
and its structure does not depend on the underlying forward model.
Hence, the example adjoint main loop given in this section is a good starting point for any adjoint main loop implementation with libadjoint.

The core function in the adjoint main loop is \refapi{adj_get_adjoint_equation}.
It assembles an adjoint equation for a given functional. 
Consequently, a sketch of a possible  adjoint main loop could be:

\begin{itemize}
\item{{for i=0...Number of functional}}
    \begin{itemize}
      \item{for j=0...Number of adjoint equations} 
      \begin{itemize}
        \item{Call \refapi{adj_get_adjoint_equation} to assemble the j'th adjoint equation for functional i.}
        \item{Solve the adjoint equation and call \refapi{adj_record_variable} to record the solution.}
      \end{itemize}
      \item{Call \refapi{adj_forget_adjoint_equation} to forget all recorded adjoint variables.}
    \end{itemize}
\item{Call \refapi{adj_forget_adjoint_equation} to forget all recorded forward variables.}
\end{itemize}

Although this adjoint main loop would work, it has one big disadvantage: 
The adjoint loop is solved independently for each functional. 
Hence the recorded dependency variables are requested separately for each functional. 
Depending on the storage strategy of these variables, each of these request might be very expensive and might even involve running parts of the forward run again.

A more efficient adjoint main loop implementation is obtained by looping over the adjoint equations first and then over the functionals:



The function \refapi{adj_get_adjoint_equation} provides 


\begin{boxwithtitle}{\texttt{A typical adjoint main loop (1)}}
\begin{minipage}{\columnwidth}
\begin{fortrancode}   
  ! This example assumes that the forward model is correctly annotated,
  ! and all necessary callbacks have been registered. 

  integer :: ierr ! Contains the error code after every libdajoint library call.
  type(adj_adjointer)  :: adjointer ! The adjointer which was used to annotate 
                                    ! the forward model.
  integer :: no_timesteps, timestep ! The total number of timesteps and an 
                                    ! iterator for the timestep loop.
  integer :: start_timestep, end_timestep ! The index of the first and last 
                                          ! equation within in the current 
                                          ! timestep. 
  integer :: no_functionals, functional ! The total number of registered 
                                        ! functionals and an iterator for the 
                                        ! functional loop.
  character(len=256), dimension(no_functionals) :: functional_name ! An array of 
                    ! strings containing the name of the registered functional.

  type(adj_vector) :: rhs ! The right hand side of the adjoint equation.
  type(adj_vector) :: soln ! The solution vector of the adjoint equation.
  type(adj_matrix) :: lhs ! The left hand side matrix of the adjoint equation.
  type(adj_variable) :: adj_var ! The target variable of the adjoint equation.
  type(adj_storage_data) :: storage ! The storage object used to record the 
                                    ! adjoint solution.

  ! Get the number of registered timesteps .
  ierr = adj_timestep_count(adjointer, no_timesteps)
  call adj_chkierr(ierr)

  ! The adjoint timeloop runs backward in time.
  do timestep=no_timesteps-1,0,-1

    ! Get the index of the first and last equation of this timestep.
    ierr = adj_timestep_start_equation(adjointer, timestep, start_timestep)
    call adj_chkierr(ierr)

    ierr = adj_timestep_end_equation(adjointer, timestep, end_timestep)
    call adj_chkierr(ierr)

    ! Begin of functional loop
    ! For every functional, the adjoint equations have to be solved seperately.
    do functional=0,no_functionals-1

      ! Begin of equation loop
      ! As in the timestep loop, the equations are solved backwards.
      do equation=end_timestep,start_timestep,-1
      
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

\begin{boxwithtitle}{\texttt{A typical adjoint main loop (2)}}
\begin{minipage}{\columnwidth}
\begin{fortrancode}   
        ! Let libadjoint assemble the adjoint equation for the current 
        ! functional and equation. The result is a linear system with 
        ! left hand side lhs and right hand side rhs. The variable 
        ! this equation targets is adj_var. 
        ierr = adj_get_adjoint_equation(adjointer, equation, 
                                        trim(functional_names(functional)), 
                                        lhs, rhs, adj_var)
        call adj_chkierr(ierr)

        ! Typically, one would get some 
        !! ierr = adj_variable_get_name(adj_var, variable_name)
        !! call adj_chkierr(ierr)

        ! Retrieve previously saved details about this variable using the 
        ! libadjoint dictionary
        !! ierr = adj_dict_find(adj_path_lookup, trim(variable_name), 
        !                       solver_options)
        !! call adj_chkierr(ierr)

        ! Depending on lhs%klass and rhs%klass one might use different 
        ! solver strategies to solve the adjoint equation.

        ! Solve lhs . adjoint = rhs 
        call solve(soln, lhs, rhs)

        ! Record the adjoint solution. 
        ! In this example, a copy of the solution vector is stored in memory.
        ierr = adj_storage_memory_copy(soln, storage)
        call adj_chkierr(ierr)

        ierr = adj_record_variable(adjointer, adj_var, storage)
        call adj_chkierr(ierr)

        ! Destroy lhs and rhs
        call femtools_vec_destroy_proc(rhs)
        call femtools_mat_destroy_proc(lhs)

      end do ! End of equation loop
      
    end do ! End of functional loop

    ! Now forget
    ierr = adj_forget_adjoint_equation(adjointer, start_timestep)
    call adj_chkierr(ierr)

  end do ! End of timestep loop

  ! Forget everything
  ierr = adj_forget_adjoint_equation(adjointer, 0)
  call adj_chkierr(ierr)
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}


In this adjoint loop template, a number of libadjoint function were used which are now described in detail:


\defapis{adj_equation_count}

\begin{boxwithtitle}{\texttt{adj_equation_count}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_equation_count(adj_adjointer* adjointer, int* count)
\end{ccode}
\begin{fortrancode}   
  function adj_equation_count(adjointer, count) result(ierr) 
    type(adj_adjointer), intent(in) :: adjointer
    integer(kind=c_int), intent(inout) :: count
    integer(kind=c_int) :: ierr
  end function adj_equation_count
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function queries the total number of registered equations in \texttt{adjointer}.
The result can be accessed with \texttt{count}.

The function returns an error code that can be passed to \refapi{adj_chkierr}.


\defapis{adj_timestep_count}

\begin{boxwithtitle}{\texttt{adj_timestep_count}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_timestep_count(adj_adjointer* adjointer, int* count)
\end{ccode}
\begin{fortrancode}   
  function adj_timestep_count(adjointer, count) result(ierr) 
    type(adj_adjointer), intent(in) :: adjointer
    integer(kind=c_int), intent(out) :: count
    integer(kind=c_int) :: ierr
  end function adj_timestep_count
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function queries the total number of timesteps in \texttt{adjointer}.
The result can be accessed with \texttt{count}.

The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_iteration_count}

\begin{boxwithtitle}{\texttt{adj_iteration_count}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_iteration_count(adj_adjointer* adjointer, adj_variable variable, 
                          int* count)
\end{ccode}
\begin{fortrancode}   
  function adj_iteration_count(adjointer, variable, count) result(ierr) 
    type(adj_adjointer), intent(in) :: adjointer
    type(adj_variable), intent(in), value :: variable
    integer(kind=c_int), intent(out) :: count
    integer(kind=c_int) :: ierr
  end function adj_iteration_count
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function queries the number iterations for variable \texttt{variable} at the variable's timestep.
If no iteration is found an \refapi{ADJ_ERR_INVALID_INPUTS} error code is returned.
The result can be accessed with \texttt{count}.

The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_timestep_start_equation}

\begin{boxwithtitle}{\texttt{adj_timestep_start_equation}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_timestep_start_equation(adj_adjointer* adjointer, int timestep, 
                                  int* start)
\end{ccode}
\begin{fortrancode}   
  function adj_timestep_start_equation(adjointer, timestep, start) result(ierr) 
    type(adj_adjointer), intent(in) :: adjointer
    integer(kind=c_int), intent(in), value :: timestep
    integer(kind=c_int), intent(out) :: start
    integer(kind=c_int) :: ierr
  end function adj_timestep_start_equation
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function returns the index of the first registered equation for the supplied timstep.
It is commonly used in combination with \refapi{adj_timestep_end_equation} and \refapi{adj_get_adjoint_equation} (or \refapi{adj_get_forward_equation}) to loop over every equation in a timestep.

Since \texttt{libadjoint} assumes that the equations are registered chronologically, \refapi{adj_timestep_start_equation} and \refapi{adj_timestep_end_equation} can be used to loop over the registered equations of one timestep.


The function returns an error code that can be passed to \refapi{adj_chkierr}.


\defapis{adj_timestep_end_equation}

\begin{boxwithtitle}{\texttt{adj_timestep_end_equation}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_timestep_end_equation(adj_adjointer* adjointer, int timestep, int* end)
\end{ccode}
\begin{fortrancode}   
  function adj_timestep_end_equation(adjointer, timestep, end) result(ierr) 
    type(adj_adjointer), intent(in) :: adjointer
    integer(kind=c_int), intent(in), value :: timestep
    integer(kind=c_int), intent(out) :: end
    integer(kind=c_int) :: ierr
  end function adj_timestep_end_equation
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function returns the index of the last registered equation for the supplied timstep.
It is commonly used in combination with \refapi{adj_timestep_start_equation} and \refapi{adj_get_adjoint_equation} (or \refapi{adj_get_forward_equation}) to loop over every equation in a timestep.

Since \texttt{libadjoint} assumes that the equations are registered chronologically, \refapi{adj_timestep_start_equation} and \refapi{adj_timestep_end_equation} can be used to loop over the registered equations of one timestep.

The function returns an error code that can be passed to \refapi{adj_chkierr}.



\defapis{adj_timestep_get_times}

\begin{boxwithtitle}{\texttt{adj_timestep_get_times}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_timestep_get_times(adj_adjointer* adjointer, int timestep, 
                             adj_scalar* start, adj_scalar* end)
\end{ccode}
\begin{fortrancode}   
  function adj_timestep_get_times(adjointer, timestep, start, end) result(ierr) 
    type(adj_adjointer), intent(in) :: adjointer
    integer(kind=c_int), intent(in), value :: timestep
    adj_scalar_f, intent(out) :: start
    adj_scalar_f, intent(out) :: end
    integer(kind=c_int) :: ierr
  end function adj_timestep_get_times
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

This function queries the start and end time of the supplied timestep \texttt{timestep}. 
For this function to work, the start and end time must have been defined previously with \refapi{adj_timestep_set_times}.
If that is not the case an \refapi{ADJ_ERR_INVALID_INPUTS} error code is returned.

The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_forget_adjoint_equation}

\begin{boxwithtitle}{\texttt{adj_forget_adjoint_equation}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_forget_adjoint_equation(adj_adjointer* adjointer, int equation)
\end{ccode}
\begin{fortrancode}   
  function adj_forget_adjoint_equation(adjointer, equation) result(ierr) 
    type(adj_adjointer), intent(inout) :: adjointer
    integer(kind=c_int), intent(in), value :: equation
    integer(kind=c_int) :: ierr
  end function adj_forget_adjoint_equation
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}


The function returns an error code that can be passed to \refapi{adj_chkierr}.

\section{Replaying the forward run} \label{sec:replay}
\defapis{adj_get_forward_equation}

\begin{boxwithtitle}{\texttt{adj_get_forward_equation}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_get_forward_equation(adj_adjointer* adjointer, int equation, 
                               adj_matrix* lhs, adj_vector* rhs, 
                               adj_variable* fwd_var);
\end{ccode}
\begin{fortrancode}   
  function adj_get_forward_equation(adjointer, equation, lhs, rhs, fwd_var) 
           result(ierr) 
    type(adj_adjointer), intent(inout) :: adjointer
    integer(kind=c_int), intent(in), value :: equation
    type(adj_matrix), intent(out) :: lhs
    type(adj_vector), intent(out) :: rhs
    type(adj_variable), intent(out) :: fwd_var
    integer(kind=c_int) :: ierr
  end function adj_get_forward_equation
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

The function returns an error code that can be passed to \refapi{adj_chkierr}.

\defapis{adj_evaluate_functional}

\begin{boxwithtitle}{\texttt{adj_evaluate_functional}}
\begin{minipage}{\columnwidth}
\begin{ccode}
  int adj_evaluate_functional(adj_adjointer* adjointer, int timestep, 
                              char* functional, adj_scalar* output)
\end{ccode}
\begin{fortrancode}   
  function adj_evaluate_functional(adjointer, timestep, functional, output) 
           result(ierr)
    type(adj_adjointer), intent(inout) :: adjointer
    integer, intent(in) :: timestep
    character(len=*), intent(in) :: functional
    adj_scalar_f, intent(out) :: output
    integer :: ierr
  end function adj_evaluate_functional
\end{fortrancode}
\end{minipage}
\end{boxwithtitle}

The function returns an error code that can be passed to \refapi{adj_chkierr}.


