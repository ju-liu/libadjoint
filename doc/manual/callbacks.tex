\chapter{Callbacks} \label{chap:callbacks}

\begin{synopsis}
\end{synopsis}
\minitoc
\vspace{\fill}
\newpage

\section{Data callbacks}
\subsection{The \texttt{adj_vector} and \texttt{adj_matrix} types}
\defapiss{adj_vector}
\defapiss{adj_matrix}
\subsection{Registering data callbacks}
\defapiss{adj_register_data_callback}
\subsection{Vector callbacks}
\defapiss{ADJ_VEC_DUPLICATE_CB}
\definterface{
  void vec_duplicate_proc(adj_vector x, adj_vector *newx);
}{
  subroutine adj_vec_duplicate_proc(x, newx) bind(c)
    type(adj_vector), intent(in), value :: x
    type(adj_vector), intent(out) :: newx
  end subroutine adj_vec_duplicate_proc
}
This data callback is the fundamental allocation callback. \libadjoint
often needs to create new vectors for various tasks; \texttt{x} is an
input model \refapi{adj_vector} to be duplicated, while \texttt{newx} is the new vector
to be allocated. Note that this callback \textbf{must initialise the contents of \texttt{newx} to zero}.

When necessary: always.
\defapiss{ADJ_VEC_AXPY_CB}
\defapiss{ADJ_VEC_DESTROY_CB}
\defapiss{ADJ_VEC_SET_VALUES_CB}
\defapiss{ADJ_VEC_DIVIDE_CB}
\defapiss{ADJ_VEC_GET_NORM_CB}
\defapiss{ADJ_VEC_SET_RANDOM_CB}
\defapiss{ADJ_VEC_DOT_PRODUCT_CB}
\subsection{Matrix callbacks}
\defapiss{ADJ_MAT_DUPLICATE_CB}
\defapiss{ADJ_MAT_AXPY_CB}
\defapiss{ADJ_MAT_DESTROY_CB}
\subsection{Supplied data callbacks}
\defapiss{adj_set_petsc_data_callbacks}

\section{Operator callbacks}
\defapis{adj_register_operator_callback}

\section{Source-term callbacks}
\defapis{adj_register_forward_source_callback}
\defapis{adj_register_functional_derivative_callback}

\section{Functional evaluation callbacks}
\defapis{adj_register_functional_callback}
